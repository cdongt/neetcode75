## ğŸš æè¿°
ç»™å®šä¸€ä¸ª m x n äºŒç»´å­—ç¬¦ç½‘æ ¼ board å’Œä¸€ä¸ªå•è¯ï¼ˆå­—ç¬¦ä¸²ï¼‰åˆ—è¡¨ wordsï¼Œ è¿”å›æ‰€æœ‰äºŒç»´ç½‘æ ¼ä¸Šçš„å•è¯ ã€‚

å•è¯å¿…é¡»æŒ‰ç…§å­—æ¯é¡ºåºï¼Œé€šè¿‡ ç›¸é‚»çš„å•å…ƒæ ¼ å†…çš„å­—æ¯æ„æˆï¼Œå…¶ä¸­â€œç›¸é‚»â€å•å…ƒæ ¼æ˜¯é‚£äº›æ°´å¹³ç›¸é‚»æˆ–å‚ç›´ç›¸é‚»çš„å•å…ƒæ ¼ã€‚åŒä¸€ä¸ªå•å…ƒæ ¼å†…çš„å­—æ¯åœ¨ä¸€ä¸ªå•è¯ä¸­ä¸å…è®¸è¢«é‡å¤ä½¿ç”¨ã€‚

![ç¤ºä¾‹1](https://vscode-picgo.oss-cn-shanghai.aliyuncs.com/vscode/20231226142253.png)

è¾“å…¥ï¼šboard = [["o","a","a","n"],["e","t","a","e"],["i","h","k","r"],["i","f","l","v"]], words = ["oath","pea","eat","rain"] <br>
è¾“å‡ºï¼š["eat","oath"]

<br>

![ç¤ºä¾‹2](https://vscode-picgo.oss-cn-shanghai.aliyuncs.com/vscode/20231226142557.png)

è¾“å…¥ï¼šboard = [["a","b"],["c","d"]], words = ["abcb"]  <br>
è¾“å‡ºï¼š[]
 

<br>
<br>
 
## ğŸ›¶ è‡ªå†™
#### ğŸ§± æ€è·¯æ€»ç»“

```python

class TreeNode:
    def __init__(self):
        self.children = {}
        self.end = False
        self.access_word = 0
        # self.word = ""


class Solution(object):
    def findWords(self, board, words):
        """
        :type board: List[List[str]]
        :type words: List[str]
        :rtype: List[str]
        """
        self.root = TreeNode()
        self.res = set()
        def make_tree():
            
            for word in words:
                node = self.root
                for w in word:
                    if w not in node.children:
                        node.children[w] = TreeNode()
                    node.access_word += 1
                    node = node.children[w]
                node.end = True
        
        def remove_wordpath(word):
            if self.root.access_word <= 0:return False
            node = self.root
            node.access_word -= 1
            for w in word:
                if w in node.children:
                    node = node.children[w]
                node.access_word -= 1
            return True 
                
        def travel():
            row,col = len(board),len(board[0])
            visit = set()
            

            def find(i,j,node,single_res):
                if node.end:
                    self.res.add(single_res)
                    node.end = False
                    if not remove_wordpath(single_res):return
                    # return 
                if (
                    i<0 or i>=row or j<0 or j>=col 
                    or (i,j) in visit  
                    or board[i][j] not in node.children
                    or node.access_word < 0
                ):
                    return 
                visit.add((i,j))
                single_res += board[i][j]
                
                find(i-1,j,node.children[board[i][j]],single_res)  
                find(i+1,j,node.children[board[i][j]],single_res) 
                find(i,j-1,node.children[board[i][j]],single_res) 
                find(i,j+1,node.children[board[i][j]],single_res)
                                          
                visit.remove((i,j))
            
            for i in range(row):
                for j in range(col):
                    if self.root.access_word <= 0:break
                    if board[i][j] not in self.root.children:continue
                    find(i,j,self.root,"")
                    
        make_tree()
        travel()
        return list(self.res)

```
 
<br>
 
#### ğŸ– ä»£ç 
 
<br>
<br>
<br>
 
## ğŸ›« å‚è€ƒ
#### ğŸŒ’ è§£é¢˜æ€è·¯ä¸€ï¼š

å•è¯çš„æœ€åä¸€ä¸ªå­—æ¯èŠ‚ç‚¹å­˜å‚¨å­—ç¬¦ä¸²

```python

class TreeNode:
    def __init__(self):
        self.children = {}
        self.word = ""
        self.access = 0
        self.end = False


class Solution(object):
    def findWords(self, board, words):
        """
        :type board: List[List[str]]
        :type words: List[str]
        :rtype: List[str]
        """
        

        def make_tries():
            for w in words:
                root.access += 1
                node = root
              
                for l in w:
                    if l not in node.children:
                        node.children[l] = TreeNode()
                    node.access += 1
                    node = node.children[l]
                node.word = w
                node.end = True

        def removeword(word):
            root.access -= 1
            node = root
            for l in word:
                node = node.children[l]
                node.access -= 1

        

        def search(i,j,node):
            if node.end:
                res.add(node.word)
                removeword(node.word)
                node.end = False

            if (
                i < 0 or i >= row or
                j < 0 or j >= col or
                (i,j) in visit or
                node.access < 0 or
                board[i][j]  not in node.children
            ):
                return False
           
            

            visit.add((i,j))
            node = node.children[board[i][j]]
            search(i,j-1,node)
            search(i,j+1,node)
            search(i-1,j,node)     
            search(i+1,j,node)
            visit.remove((i,j))     

        root = TreeNode()
        res,visit = set(),set()
        row,col = len(board),len(board[0])
        make_tries()
        for i in range(row):
            for j in range(col):
                search(i,j,root)
        return list(res)
        

```

 
<br>
 
#### ğŸŒ“ è§£é¢˜æ€è·¯äºŒï¼š



```python

class TrieNode:
    def __init__(self):
        self.children = {}
        self.isWord = False
        self.refs = 0

    def addWord(self, word):
        cur = self
        cur.refs += 1
        for c in word:
            if c not in cur.children:
                cur.children[c] = TrieNode()
            cur = cur.children[c]
            cur.refs += 1
        cur.isWord = True

    def removeWord(self, word):
        cur = self
        cur.refs -= 1
        for c in word:
            if c in cur.children:
                cur = cur.children[c]
                cur.refs -= 1


class Solution:
    def findWords(self, board: List[List[str]], words: List[str]) -> List[str]:
        root = TrieNode()
        for w in words:
            root.addWord(w)

        ROWS, COLS = len(board), len(board[0])
        res, visit = set(), set()

        def dfs(r, c, node, word):
            if (
                r not in range(ROWS) 
                or c not in range(COLS)
                or board[r][c] not in node.children
                or node.children[board[r][c]].refs < 1
                or (r, c) in visit
            ):
                return

            visit.add((r, c))
            node = node.children[board[r][c]]
            word += board[r][c]
            if node.isWord:
                node.isWord = False
                res.add(word)
                root.removeWord(word)

            dfs(r + 1, c, node, word)
            dfs(r - 1, c, node, word)
            dfs(r, c + 1, node, word)
            dfs(r, c - 1, node, word)
            visit.remove((r, c))

        for r in range(ROWS):
            for c in range(COLS):
                dfs(r, c, root, "")

        return list(res)


```
 

<br>
<br>
<br>
 
## ğŸŒŠ åæ€ç¯èŠ‚
- é€’å½’ä¸­å¦‚ä½•å­˜å‚¨ä¸­é—´ç»“æœï¼š
  - åˆ©ç”¨å…¨å±€å˜é‡ï¼šç¼ºç‚¹ï¼šé€’å½’è°ƒç”¨æ—¶ä¼šè®¿é—®ä¿®æ”¹ç›¸åŒçš„å…¨å±€å˜é‡ï¼Œå¯¼è‡´è¦†ç›–
  - åˆ©ç”¨ç±»å±æ€§ï¼Œå¦‚ `self.word = w`
  - åˆ©ç”¨å‚æ•°ä¼ é€’ï¼šå°†ä¸­é—´ç»“æœä½œä¸ºå‚æ•°ä¼ é€’ç»™é€’å½’å‡½æ•°
  - åˆ©ç”¨å­—å…¸æˆ–å“ˆå¸Œè¡¨
  - [æš‚æœªä½¿ç”¨]ç¼“å­˜ï¼ˆMemoizationï¼‰ï¼š Memoization æ˜¯ä¸€ç§å°†å‡½æ•°çš„è¿”å›å€¼ç¼“å­˜èµ·æ¥ä»¥é¿å…é‡å¤è®¡ç®—çš„æŠ€æœ¯ã€‚åœ¨é€’å½’å‡½æ•°ä¸­ï¼Œå¯ä»¥å°†è®¡ç®—è¿‡çš„ç»“æœå­˜å‚¨åœ¨ç¼“å­˜ä¸­ï¼Œä¸‹æ¬¡éœ€è¦ç›¸åŒå‚æ•°è®¡ç®—æ—¶ç›´æ¥è¿”å›ç¼“å­˜çš„ç»“æœï¼Œè€Œä¸ç”¨é‡æ–°è®¡ç®—ã€‚
  - åŠ¨æ€è§„åˆ’
  - ä½¿ç”¨é—­åŒ…


<br>
<br>
<br>
 